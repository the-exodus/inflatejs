/**
 * TypeScript Compilation Tests
 *
 * These tests verify that the TypeScript output generated by the unminifier
 * actually compiles without errors using the TypeScript compiler.
 *
 * Run these tests separately from the main test suite:
 * npm run test:compilation
 */

import { describe, it, expect } from 'vitest';
import { unminify } from '../unminifier-facade';
import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

/**
 * Compile TypeScript code and return diagnostics
 */
function compileTypeScript(code: string): ts.Diagnostic[] {
  const options: ts.CompilerOptions = {
    target: ts.ScriptTarget.ES2020,
    module: ts.ModuleKind.ESNext,
    strict: true,
    noEmit: true,
    skipLibCheck: true,
  };

  const host = ts.createCompilerHost(options);
  const fileName = 'test.ts';

  // Override readFile to provide our generated code
  const originalReadFile = host.readFile;
  host.readFile = (fname: string) => {
    if (fname === fileName) {
      return code;
    }
    return originalReadFile.call(host, fname);
  };

  // Override fileExists to claim our test file exists
  const originalFileExists = host.fileExists;
  host.fileExists = (fname: string) => {
    if (fname === fileName) {
      return true;
    }
    return originalFileExists.call(host, fname);
  };

  const program = ts.createProgram([fileName], options, host);
  const diagnostics = ts.getPreEmitDiagnostics(program);

  return diagnostics.filter(d =>
    d.file?.fileName === fileName || !d.file
  );
}

/**
 * Format TypeScript diagnostics for readable error messages
 */
function formatDiagnostics(diagnostics: ts.Diagnostic[]): string {
  return diagnostics.map(diagnostic => {
    if (diagnostic.file) {
      const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start!);
      const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
      return `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`;
    } else {
      return ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
    }
  }).join('\n');
}

describe('TypeScript Compilation Tests', () => {
  describe('Phase 1 Features', () => {
    it('should compile template literals', async () => {
      const code = 'const username="John";const greeting=`Hello, ${username}!`;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile unary expressions', async () => {
      const code = 'const isActive=true;const isInactive=!isActive;const typeStr=typeof 42;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile conditional expressions', async () => {
      const code = 'const isDev=true;const mode=isDev?"debug":"production";';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile array/string method calls', async () => {
      const code = 'const arr=[1,2,3];const doubled=arr.map(x=>x*2);const text="hello";const upper=text.toUpperCase();';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });

  describe('Phase 2 Features', () => {
    it('should compile logical expressions', async () => {
      const code = 'const input="";const value=input||"default";const flag=true;const result=flag&&"done";';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile RegExp literals', async () => {
      const code = 'const pattern=/test/i;const isMatch=pattern.test("TEST");';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile static methods', async () => {
      const code = 'const obj={a:1,b:2};const keys=Object.keys(obj);const arr=[1,2,3];const isArr=Array.isArray(arr);';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile union types', async () => {
      const code = 'const flag=true;const result=flag?"success":404;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile context-aware methods', async () => {
      const code = 'const text="hello world";const sliced=text.slice(0,5);const arr=[1,2,3];const arrSliced=arr.slice(0,2);';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });

  describe('Complex scenarios', () => {
    it('should compile chained method calls', async () => {
      const code = 'const text="hello world";const result=text.slice(0,5).toUpperCase();const arr=[1,2,3,4,5];const filtered=arr.slice(0,4).filter(x=>x>2);';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile nested conditionals with unions', async () => {
      const code = 'const score=85;const level=score>90?"A":score>70?"B":0;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile mixed operations', async () => {
      const code = 'const flag=true;const arr=[1,2,3];const text="hello";const num=42;const result=flag?arr.map(x=>x*2):text.split("").map(c=>c.toUpperCase());';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile undefined and null unions', async () => {
      const code = 'const flag=true;const result1=flag?"text":null;const result2=flag?42:undefined;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile array of different types', async () => {
      const code = 'const flag=true;const nums=[1,2,3];const strs=["a","b","c"];const result=flag?nums:strs;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });

  describe('Phase 3 Features', () => {
    it('should compile default parameters', async () => {
      const code = 'function greet(name="World"){return `Hello, ${name}!`;}const msg1=greet();const msg2=greet("Alice");';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile rest parameters', async () => {
      const code = 'function sum(...nums){return nums.reduce((a,b)=>a+b,0);}const total=sum(1,2,3,4);';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile spread operator in arrays', async () => {
      const code = 'const arr1=[1,2,3];const arr2=[...arr1,4,5];const combined=[...arr1,...arr2];';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile spread operator in function calls', async () => {
      const code = 'const nums=[1,2,3];const max=Math.max(...nums);const min=Math.min(...nums);';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile spread operator in objects', async () => {
      const code = 'const obj1={x:1,y:2};const obj2={...obj1,z:3};const merged={...obj1,...obj2};';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile mixed default and rest parameters', async () => {
      const code = 'function fn(a=1,b=2,...rest){return a+b+rest.length;}const result=fn();';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile optional chaining property access', async () => {
      const code = 'const user={username:"John"};const userName=user?.username;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      // Verify optional chaining syntax is preserved
      expect(result).toContain('?.');
    });

    it('should compile optional chaining method calls', async () => {
      const code = 'const text="hello";const upper=text?.toUpperCase();';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile nested optional chaining', async () => {
      const code = 'const x={y:{z:1}};const val=x?.y?.z;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      // Verify optional chaining syntax is preserved
      expect(result).toContain('?.');
    });

    it('should compile optional element access', async () => {
      const code = 'const arr=[1,2,3];const first=arr?.[0];';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });

  describe('Real-world scenarios', () => {
    it('should compile data processing pipeline', async () => {
      const code = `
        const data=[1,2,3,4,5];
        const filtered=data.filter(x=>x>2);
        const doubled=filtered.map(x=>x*2);
        const result=doubled.join(",");
      `;
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile string manipulation', async () => {
      const code = `
        const input="  Hello World  ";
        const trimmed=input.trim();
        const lower=trimmed.toLowerCase();
        const words=lower.split(" ");
        const first=words[0];
      `;
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile validation logic', async () => {
      const code = `
        const email="test@example.com";
        const hasAt=email.includes("@");
        const parts=email.split("@");
        const isValid=hasAt&&parts.length===2;
        const domain=isValid?parts[1]:"unknown";
      `;
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });

  describe('Phase 4 Features', () => {
    it('should compile basic class with methods', async () => {
      const code = 'class Point{constructor(x,y){this.x=x;this.y=y;}distance(){return Math.sqrt(this.x*this.x+this.y*this.y);}}';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile class with static methods', async () => {
      const code = 'class Calculator{static add(a,b){return a+b;}static multiply(a,b){return a*b;}}';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile class with getters and setters', async () => {
      const code = 'class Counter{constructor(){this._count=0;}get count(){return this._count;}set count(v){this._count=v;}increment(){this._count++;}}';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile class inheritance', async () => {
      const code = 'class Animal{speak(){return"sound";}}class Dog extends Animal{bark(){return"woof";}}';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile class with super call', async () => {
      const code = 'class Point{constructor(x,y){this.x=x;this.y=y;}}class Point3D extends Point{constructor(x,y,z){super(x,y);this.z=z;}}';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile class with mixed parameter types', async () => {
      const code = 'class Service{process(required,optional=10,...rest){return required+optional+rest.length;}}';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile class expression', async () => {
      const code = 'const MyClass=class{getValue(){return 42;}};';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile object destructuring', async () => {
      const code = 'const user={name:"John",age:30};const {name,age}=user;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile array destructuring', async () => {
      const code = 'const coords=[10,20];const [x,y]=coords;const sum=x+y;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile nested destructuring', async () => {
      const code = 'const data={user:{name:"John",coords:[10,20]}};const {user:{name,coords:[x,y]}}=data;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile parameter destructuring', async () => {
      const code = 'function greet({name,age}){return `${name} is ${age}`;}function sum([a,b]){return a+b;}';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile destructuring with default values', async () => {
      const code = 'const obj={x:1};const {x,y=2}=obj;const arr=[1];const [a,b=2]=arr;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile destructuring with rest elements', async () => {
      const code = 'const obj={a:1,b:2,c:3};const {a,...rest}=obj;const arr=[1,2,3];const [first,...others]=arr;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });
});

/**
 * TypeScript Compilation Tests
 *
 * These tests verify that the TypeScript output generated by the unminifier
 * actually compiles without errors using the TypeScript compiler.
 *
 * Run these tests separately from the main test suite:
 * npm run test:compilation
 */

import { describe, it, expect } from 'vitest';
import { unminify } from '../unminifier-facade';
import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

/**
 * Compile TypeScript code and return diagnostics
 */
function compileTypeScript(code: string): ts.Diagnostic[] {
  const options: ts.CompilerOptions = {
    target: ts.ScriptTarget.ES2020,
    module: ts.ModuleKind.ESNext,
    strict: true,
    noEmit: true,
    skipLibCheck: true,
  };

  const host = ts.createCompilerHost(options);
  const fileName = 'test.ts';

  // Override readFile to provide our generated code
  const originalReadFile = host.readFile;
  host.readFile = (fname: string) => {
    if (fname === fileName) {
      return code;
    }
    return originalReadFile.call(host, fname);
  };

  // Override fileExists to claim our test file exists
  const originalFileExists = host.fileExists;
  host.fileExists = (fname: string) => {
    if (fname === fileName) {
      return true;
    }
    return originalFileExists.call(host, fname);
  };

  const program = ts.createProgram([fileName], options, host);
  const diagnostics = ts.getPreEmitDiagnostics(program);

  return diagnostics.filter(d =>
    d.file?.fileName === fileName || !d.file
  );
}

/**
 * Format TypeScript diagnostics for readable error messages
 */
function formatDiagnostics(diagnostics: ts.Diagnostic[]): string {
  return diagnostics.map(diagnostic => {
    if (diagnostic.file) {
      const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start!);
      const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
      return `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`;
    } else {
      return ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
    }
  }).join('\n');
}

describe('TypeScript Compilation Tests', () => {
  describe('Phase 1 Features', () => {
    it('should compile template literals', async () => {
      const code = 'const username="John";const greeting=`Hello, ${username}!`;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile unary expressions', async () => {
      const code = 'const isActive=true;const isInactive=!isActive;const typeStr=typeof 42;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile conditional expressions', async () => {
      const code = 'const isDev=true;const mode=isDev?"debug":"production";';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile array/string method calls', async () => {
      const code = 'const arr=[1,2,3];const doubled=arr.map(x=>x*2);const text="hello";const upper=text.toUpperCase();';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });

  describe('Phase 2 Features', () => {
    it('should compile logical expressions', async () => {
      const code = 'const input="";const value=input||"default";const flag=true;const result=flag&&"done";';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile RegExp literals', async () => {
      const code = 'const pattern=/test/i;const isMatch=pattern.test("TEST");';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile static methods', async () => {
      const code = 'const obj={a:1,b:2};const keys=Object.keys(obj);const arr=[1,2,3];const isArr=Array.isArray(arr);';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile union types', async () => {
      const code = 'const flag=true;const result=flag?"success":404;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile context-aware methods', async () => {
      const code = 'const text="hello world";const sliced=text.slice(0,5);const arr=[1,2,3];const arrSliced=arr.slice(0,2);';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });

  describe('Complex scenarios', () => {
    it('should compile chained method calls', async () => {
      const code = 'const text="hello world";const result=text.slice(0,5).toUpperCase();const arr=[1,2,3,4,5];const filtered=arr.slice(0,4).filter(x=>x>2);';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile nested conditionals with unions', async () => {
      const code = 'const score=85;const level=score>90?"A":score>70?"B":0;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile mixed operations', async () => {
      const code = 'const flag=true;const arr=[1,2,3];const text="hello";const num=42;const result=flag?arr.map(x=>x*2):text.split("").map(c=>c.toUpperCase());';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile undefined and null unions', async () => {
      const code = 'const flag=true;const result1=flag?"text":null;const result2=flag?42:undefined;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile array of different types', async () => {
      const code = 'const flag=true;const nums=[1,2,3];const strs=["a","b","c"];const result=flag?nums:strs;';
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });

  describe('Real-world scenarios', () => {
    it('should compile data processing pipeline', async () => {
      const code = `
        const data=[1,2,3,4,5];
        const filtered=data.filter(x=>x>2);
        const doubled=filtered.map(x=>x*2);
        const result=doubled.join(",");
      `;
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile string manipulation', async () => {
      const code = `
        const input="  Hello World  ";
        const trimmed=input.trim();
        const lower=trimmed.toLowerCase();
        const words=lower.split(" ");
        const first=words[0];
      `;
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });

    it('should compile validation logic', async () => {
      const code = `
        const email="test@example.com";
        const hasAt=email.includes("@");
        const parts=email.split("@");
        const isValid=hasAt&&parts.length===2;
        const domain=isValid?parts[1]:"unknown";
      `;
      const result = await unminify(code, { inferTypes: true, outputFormat: 'ts' });

      const diagnostics = compileTypeScript(result);
      expect(diagnostics.length, `Compilation errors:\n${formatDiagnostics(diagnostics)}`).toBe(0);
    });
  });
});
